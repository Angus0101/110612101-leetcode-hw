class Solution:
    def minSwapsCouples(self, row: List[int]) -> int:
        # 定義一個函數 `find` 來查找某個節點的代表元 (使用路徑壓縮優化)
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])  # 路徑壓縮，使查找更快
            return parent[x]
        
        # 定義 `union` 函數來合併兩個集合
        def union(x, y):
            rootX = find(x)
            rootY = find(y)
            if rootX != rootY:
                parent[rootX] = rootY  # 讓 `rootX` 指向 `rootY`，合併集合

        n = len(row) // 2  # 計算情侶對的數量
        parent = [i for i in range(n)]  # 初始化並查集，每個情侶對獨立一組
        
        # 遍歷每對情侶
        for i in range(0, len(row), 2):
            # 兩人分別位於 row[i] 和 row[i+1]，將其對應的情侶組合 (row[i]//2) 和 (row[i+1]//2) 進行合併
            union(row[i] // 2, row[i+1] // 2)
        
        # 計算聯通分量的數量，`find(x)` 會給出該組的代表元
        count = sum([1 for i, x in enumerate(parent) if i == find(x)])
        
        # 需要的交換次數 = 總組數 - 連通塊數
        return n - count
